{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar parser = require('postcss-value-parser');\n\nvar list = require('postcss').list;\n\nvar uniq = require('../utils').uniq;\n\nvar escapeRegexp = require('../utils').escapeRegexp;\n\nvar splitSelector = require('../utils').splitSelector;\n\nfunction convert(value) {\n  if (value && value.length === 2 && value[0] === 'span' && parseInt(value[1], 10) > 0) {\n    return [false, parseInt(value[1], 10)];\n  }\n\n  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {\n    return [parseInt(value[0], 10), false];\n  }\n\n  return [false, false];\n}\n\nfunction translate(values, startIndex, endIndex) {\n  var startValue = values[startIndex];\n  var endValue = values[endIndex];\n\n  if (!startValue) {\n    return [false, false];\n  }\n\n  var _convert = convert(startValue),\n      start = _convert[0],\n      spanStart = _convert[1];\n\n  var _convert2 = convert(endValue),\n      end = _convert2[0],\n      spanEnd = _convert2[1];\n\n  if (start && !endValue) {\n    return [start, false];\n  }\n\n  if (spanStart && end) {\n    return [end - spanStart, spanStart];\n  }\n\n  if (start && spanEnd) {\n    return [start, spanEnd];\n  }\n\n  if (start && end) {\n    return [start, end - start];\n  }\n\n  return [false, false];\n}\n\nfunction parse(decl) {\n  var node = parser(decl.value);\n  var values = [];\n  var current = 0;\n  values[current] = [];\n\n  for (var _iterator = _createForOfIteratorHelperLoose(node.nodes), _step; !(_step = _iterator()).done;) {\n    var i = _step.value;\n\n    if (i.type === 'div') {\n      current += 1;\n      values[current] = [];\n    } else if (i.type === 'word') {\n      values[current].push(i.value);\n    }\n  }\n\n  return values;\n}\n\nfunction insertDecl(decl, prop, value) {\n  if (value && !decl.parent.some(function (i) {\n    return i.prop === \"-ms-\" + prop;\n  })) {\n    decl.cloneBefore({\n      prop: \"-ms-\" + prop,\n      value: value.toString()\n    });\n  }\n} // Track transforms\n\n\nfunction prefixTrackProp(_ref) {\n  var prop = _ref.prop,\n      prefix = _ref.prefix;\n  return prefix + prop.replace('template-', '');\n}\n\nfunction transformRepeat(_ref2, _ref3) {\n  var nodes = _ref2.nodes;\n  var gap = _ref3.gap;\n\n  var _nodes$reduce = nodes.reduce(function (result, node) {\n    if (node.type === 'div' && node.value === ',') {\n      result.key = 'size';\n    } else {\n      result[result.key].push(parser.stringify(node));\n    }\n\n    return result;\n  }, {\n    key: 'count',\n    size: [],\n    count: []\n  }),\n      count = _nodes$reduce.count,\n      size = _nodes$reduce.size; // insert gap values\n\n\n  if (gap) {\n    var _ret = function () {\n      size = size.filter(function (i) {\n        return i.trim();\n      });\n      var val = [];\n\n      var _loop = function _loop(i) {\n        size.forEach(function (item, index) {\n          if (index > 0 || i > 1) {\n            val.push(gap);\n          }\n\n          val.push(item);\n        });\n      };\n\n      for (var i = 1; i <= count; i++) {\n        _loop(i);\n      }\n\n      return {\n        v: val.join(' ')\n      };\n    }();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  return \"(\" + size.join('') + \")[\" + count.join('') + \"]\";\n}\n\nfunction prefixTrackValue(_ref4) {\n  var value = _ref4.value,\n      gap = _ref4.gap;\n  var result = parser(value).nodes.reduce(function (nodes, node) {\n    if (node.type === 'function' && node.value === 'repeat') {\n      return nodes.concat({\n        type: 'word',\n        value: transformRepeat(node, {\n          gap: gap\n        })\n      });\n    }\n\n    if (gap && node.type === 'space') {\n      return nodes.concat({\n        type: 'space',\n        value: ' '\n      }, {\n        type: 'word',\n        value: gap\n      }, node);\n    }\n\n    return nodes.concat(node);\n  }, []);\n  return parser.stringify(result);\n} // Parse grid-template-areas\n\n\nvar DOTS = /^\\.+$/;\n\nfunction track(start, end) {\n  return {\n    start: start,\n    end: end,\n    span: end - start\n  };\n}\n\nfunction getColumns(line) {\n  return line.trim().split(/\\s+/g);\n}\n\nfunction parseGridAreas(_ref5) {\n  var rows = _ref5.rows,\n      gap = _ref5.gap;\n  return rows.reduce(function (areas, line, rowIndex) {\n    if (gap.row) rowIndex *= 2;\n    if (line.trim() === '') return areas;\n    getColumns(line).forEach(function (area, columnIndex) {\n      if (DOTS.test(area)) return;\n      if (gap.column) columnIndex *= 2;\n\n      if (typeof areas[area] === 'undefined') {\n        areas[area] = {\n          column: track(columnIndex + 1, columnIndex + 2),\n          row: track(rowIndex + 1, rowIndex + 2)\n        };\n      } else {\n        var _areas$area = areas[area],\n            column = _areas$area.column,\n            row = _areas$area.row;\n        column.start = Math.min(column.start, columnIndex + 1);\n        column.end = Math.max(column.end, columnIndex + 2);\n        column.span = column.end - column.start;\n        row.start = Math.min(row.start, rowIndex + 1);\n        row.end = Math.max(row.end, rowIndex + 2);\n        row.span = row.end - row.start;\n      }\n    });\n    return areas;\n  }, {});\n} // Parse grid-template\n\n\nfunction testTrack(node) {\n  return node.type === 'word' && /^\\[.+]$/.test(node.value);\n}\n\nfunction verifyRowSize(result) {\n  if (result.areas.length > result.rows.length) {\n    result.rows.push('auto');\n  }\n\n  return result;\n}\n\nfunction parseTemplate(_ref6) {\n  var decl = _ref6.decl,\n      gap = _ref6.gap;\n  var gridTemplate = parser(decl.value).nodes.reduce(function (result, node) {\n    var type = node.type,\n        value = node.value;\n    if (testTrack(node) || type === 'space') return result; // area\n\n    if (type === 'string') {\n      result = verifyRowSize(result);\n      result.areas.push(value);\n    } // values and function\n\n\n    if (type === 'word' || type === 'function') {\n      result[result.key].push(parser.stringify(node));\n    } // divider(/)\n\n\n    if (type === 'div' && value === '/') {\n      result.key = 'columns';\n      result = verifyRowSize(result);\n    }\n\n    return result;\n  }, {\n    key: 'rows',\n    columns: [],\n    rows: [],\n    areas: []\n  });\n  return {\n    areas: parseGridAreas({\n      rows: gridTemplate.areas,\n      gap: gap\n    }),\n    columns: prefixTrackValue({\n      value: gridTemplate.columns.join(' '),\n      gap: gap.column\n    }),\n    rows: prefixTrackValue({\n      value: gridTemplate.rows.join(' '),\n      gap: gap.row\n    })\n  };\n} // Insert parsed grid areas\n\n/**\n * Get an array of -ms- prefixed props and values\n * @param  {Object} [area] area object with column and row data\n * @param  {Boolean} [addRowSpan] should we add grid-column-row value?\n * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?\n * @return {Array<Object>}\n */\n\n\nfunction getMSDecls(area, addRowSpan, addColumnSpan) {\n  if (addRowSpan === void 0) {\n    addRowSpan = false;\n  }\n\n  if (addColumnSpan === void 0) {\n    addColumnSpan = false;\n  }\n\n  return [].concat({\n    prop: '-ms-grid-row',\n    value: String(area.row.start)\n  }, area.row.span > 1 || addRowSpan ? {\n    prop: '-ms-grid-row-span',\n    value: String(area.row.span)\n  } : [], {\n    prop: '-ms-grid-column',\n    value: String(area.column.start)\n  }, area.column.span > 1 || addColumnSpan ? {\n    prop: '-ms-grid-column-span',\n    value: String(area.column.span)\n  } : []);\n}\n\nfunction getParentMedia(parent) {\n  if (parent.type === 'atrule' && parent.name === 'media') {\n    return parent;\n  }\n\n  if (!parent.parent) {\n    return false;\n  }\n\n  return getParentMedia(parent.parent);\n}\n/**\n * change selectors for rules with duplicate grid-areas.\n * @param  {Array<Rule>} rules\n * @param  {Array<String>} templateSelectors\n * @return {Array<Rule>} rules with changed selectors\n */\n\n\nfunction changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {\n  ruleSelectors = ruleSelectors.map(function (selector) {\n    var selectorBySpace = list.space(selector);\n    var selectorByComma = list.comma(selector);\n\n    if (selectorBySpace.length > selectorByComma.length) {\n      selector = selectorBySpace.slice(-1).join('');\n    }\n\n    return selector;\n  });\n  return ruleSelectors.map(function (ruleSelector) {\n    var newSelector = templateSelectors.map(function (tplSelector, index) {\n      var space = index === 0 ? '' : ' ';\n      return \"\" + space + tplSelector + \" > \" + ruleSelector;\n    });\n    return newSelector;\n  });\n}\n/**\n * check if selector of rules are equal\n * @param  {Rule} ruleA\n * @param  {Rule} ruleB\n * @return {Boolean}\n */\n\n\nfunction selectorsEqual(ruleA, ruleB) {\n  return ruleA.selectors.some(function (sel) {\n    return ruleB.selectors.some(function (s) {\n      return s === sel;\n    });\n  });\n}\n/**\n * Parse data from all grid-template(-areas) declarations\n * @param  {Root} css css root\n * @return {Object} parsed data\n */\n\n\nfunction parseGridTemplatesData(css) {\n  var parsed = []; // we walk through every grid-template(-areas) declaration and store\n  // data with the same area names inside the item\n\n  css.walkDecls(/grid-template(-areas)?$/, function (d) {\n    var rule = d.parent;\n    var media = getParentMedia(rule);\n    var gap = getGridGap(d);\n    var inheritedGap = inheritGridGap(d, gap);\n\n    var _parseTemplate = parseTemplate({\n      decl: d,\n      gap: inheritedGap || gap\n    }),\n        areas = _parseTemplate.areas;\n\n    var areaNames = Object.keys(areas); // skip node if it doesn't have areas\n\n    if (areaNames.length === 0) {\n      return true;\n    } // check parsed array for item that include the same area names\n    // return index of that item\n\n\n    var index = parsed.reduce(function (acc, _ref7, idx) {\n      var allAreas = _ref7.allAreas;\n      var hasAreas = allAreas && areaNames.some(function (area) {\n        return allAreas.includes(area);\n      });\n      return hasAreas ? idx : acc;\n    }, null);\n\n    if (index !== null) {\n      // index is found, add the grid-template data to that item\n      var _parsed$index = parsed[index],\n          allAreas = _parsed$index.allAreas,\n          rules = _parsed$index.rules; // check if rule has no duplicate area names\n\n      var hasNoDuplicates = rules.some(function (r) {\n        return r.hasDuplicates === false && selectorsEqual(r, rule);\n      });\n      var duplicatesFound = false; // check need to gather all duplicate area names\n\n      var duplicateAreaNames = rules.reduce(function (acc, r) {\n        if (!r.params && selectorsEqual(r, rule)) {\n          duplicatesFound = true;\n          return r.duplicateAreaNames;\n        }\n\n        if (!duplicatesFound) {\n          areaNames.forEach(function (name) {\n            if (r.areas[name]) {\n              acc.push(name);\n            }\n          });\n        }\n\n        return uniq(acc);\n      }, []); // update grid-row/column-span values for areas with duplicate\n      // area names. @see #1084 and #1146\n\n      rules.forEach(function (r) {\n        areaNames.forEach(function (name) {\n          var area = r.areas[name];\n\n          if (area && area.row.span !== areas[name].row.span) {\n            areas[name].row.updateSpan = true;\n          }\n\n          if (area && area.column.span !== areas[name].column.span) {\n            areas[name].column.updateSpan = true;\n          }\n        });\n      });\n      parsed[index].allAreas = uniq([].concat(allAreas, areaNames));\n      parsed[index].rules.push({\n        hasDuplicates: !hasNoDuplicates,\n        params: media.params,\n        selectors: rule.selectors,\n        node: rule,\n        duplicateAreaNames: duplicateAreaNames,\n        areas: areas\n      });\n    } else {\n      // index is NOT found, push the new item to the parsed array\n      parsed.push({\n        allAreas: areaNames,\n        areasCount: 0,\n        rules: [{\n          hasDuplicates: false,\n          duplicateRules: [],\n          params: media.params,\n          selectors: rule.selectors,\n          node: rule,\n          duplicateAreaNames: [],\n          areas: areas\n        }]\n      });\n    }\n\n    return undefined;\n  });\n  return parsed;\n}\n/**\n * insert prefixed grid-area declarations\n * @param  {Root}  css css root\n * @param  {Function} isDisabled check if the rule is disabled\n * @return {void}\n */\n\n\nfunction insertAreas(css, isDisabled) {\n  // parse grid-template declarations\n  var gridTemplatesData = parseGridTemplatesData(css); // return undefined if no declarations found\n\n  if (gridTemplatesData.length === 0) {\n    return undefined;\n  } // we need to store the rules that we will insert later\n\n\n  var rulesToInsert = {};\n  css.walkDecls('grid-area', function (gridArea) {\n    var gridAreaRule = gridArea.parent;\n    var hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row';\n    var gridAreaMedia = getParentMedia(gridAreaRule);\n\n    if (isDisabled(gridArea)) {\n      return undefined;\n    }\n\n    var gridAreaRuleIndex = gridAreaMedia ? css.index(gridAreaMedia) : css.index(gridAreaRule);\n    var value = gridArea.value; // found the data that matches grid-area identifier\n\n    var data = gridTemplatesData.filter(function (d) {\n      return d.allAreas.includes(value);\n    })[0];\n\n    if (!data) {\n      return true;\n    }\n\n    var lastArea = data.allAreas[data.allAreas.length - 1];\n    var selectorBySpace = list.space(gridAreaRule.selector);\n    var selectorByComma = list.comma(gridAreaRule.selector);\n    var selectorIsComplex = selectorBySpace.length > 1 && selectorBySpace.length > selectorByComma.length; // prevent doubling of prefixes\n\n    if (hasPrefixedRow) {\n      return false;\n    } // create the empty object with the key as the last area name\n    // e.g if we have templates with \"a b c\" values, \"c\" will be the last area\n\n\n    if (!rulesToInsert[lastArea]) {\n      rulesToInsert[lastArea] = {};\n    }\n\n    var lastRuleIsSet = false; // walk through every grid-template rule data\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(data.rules), _step2; !(_step2 = _iterator2()).done;) {\n      var rule = _step2.value;\n      var area = rule.areas[value];\n      var hasDuplicateName = rule.duplicateAreaNames.includes(value); // if we can't find the area name, update lastRule and continue\n\n      if (!area) {\n        var lastRuleIndex = css.index(rulesToInsert[lastArea].lastRule);\n\n        if (gridAreaRuleIndex > lastRuleIndex) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n        }\n\n        continue;\n      } // for grid-templates inside media rule we need to create empty\n      // array to push prefixed grid-area rules later\n\n\n      if (rule.params && !rulesToInsert[lastArea][rule.params]) {\n        rulesToInsert[lastArea][rule.params] = [];\n      }\n\n      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {\n        // grid-template has no duplicates and not inside media rule\n        getMSDecls(area, false, false).reverse().forEach(function (i) {\n          return gridAreaRule.prepend(Object.assign(i, {\n            raws: {\n              between: gridArea.raws.between\n            }\n          }));\n        });\n        rulesToInsert[lastArea].lastRule = gridAreaRule;\n        lastRuleIsSet = true;\n      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {\n        (function () {\n          // grid-template has duplicates and not inside media rule\n          var cloned = gridAreaRule.clone();\n          cloned.removeAll();\n          getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n            return cloned.prepend(Object.assign(i, {\n              raws: {\n                between: gridArea.raws.between\n              }\n            }));\n          });\n          cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n\n          if (rulesToInsert[lastArea].lastRule) {\n            rulesToInsert[lastArea].lastRule.after(cloned);\n          }\n\n          rulesToInsert[lastArea].lastRule = cloned;\n          lastRuleIsSet = true;\n        })();\n      } else if (rule.hasDuplicates && !rule.params && selectorIsComplex && gridAreaRule.selector.includes(rule.selectors[0])) {\n        // grid-template has duplicates and not inside media rule\n        // and the selector is complex\n        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, function (d) {\n          return d.remove();\n        });\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n          return gridAreaRule.prepend(Object.assign(i, {\n            raws: {\n              between: gridArea.raws.between\n            }\n          }));\n        });\n      } else if (rule.params) {\n        (function () {\n          // grid-template is inside media rule\n          // if we're inside media rule, we need to store prefixed rules\n          // inside rulesToInsert object to be able to preserve the order of media\n          // rules and merge them easily\n          var cloned = gridAreaRule.clone();\n          cloned.removeAll();\n          getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n            return cloned.prepend(Object.assign(i, {\n              raws: {\n                between: gridArea.raws.between\n              }\n            }));\n          });\n\n          if (rule.hasDuplicates && hasDuplicateName) {\n            cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n          }\n\n          cloned.raws = rule.node.raws;\n\n          if (css.index(rule.node.parent) > gridAreaRuleIndex) {\n            // append the prefixed rules right inside media rule\n            // with grid-template\n            rule.node.parent.append(cloned);\n          } else {\n            // store the rule to insert later\n            rulesToInsert[lastArea][rule.params].push(cloned);\n          } // set new rule as last rule ONLY if we didn't set lastRule for\n          // this grid-area before\n\n\n          if (!lastRuleIsSet) {\n            rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n          }\n        })();\n      }\n    }\n\n    return undefined;\n  }); // append stored rules inside the media rules\n\n  Object.keys(rulesToInsert).forEach(function (area) {\n    var data = rulesToInsert[area];\n    var lastRule = data.lastRule;\n    Object.keys(data).reverse().filter(function (p) {\n      return p !== 'lastRule';\n    }).forEach(function (params) {\n      if (data[params].length > 0 && lastRule) {\n        lastRule.after({\n          name: 'media',\n          params: params\n        });\n        lastRule.next().append(data[params]);\n      }\n    });\n  });\n  return undefined;\n}\n/**\n * Warn user if grid area identifiers are not found\n * @param  {Object} areas\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnMissedAreas(areas, decl, result) {\n  var missed = Object.keys(areas);\n  decl.root().walkDecls('grid-area', function (gridArea) {\n    missed = missed.filter(function (e) {\n      return e !== gridArea.value;\n    });\n  });\n\n  if (missed.length > 0) {\n    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '));\n  }\n\n  return undefined;\n}\n/**\n * compare selectors with grid-area rule and grid-template rule\n * show warning if grid-template selector is not found\n * (this function used for grid-area rule)\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnTemplateSelectorNotFound(decl, result) {\n  var rule = decl.parent;\n  var root = decl.root();\n  var duplicatesFound = false; // slice selector array. Remove the last part (for comparison)\n\n  var slicedSelectorArr = list.space(rule.selector).filter(function (str) {\n    return str !== '>';\n  }).slice(0, -1); // we need to compare only if selector is complex.\n  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex\n\n  if (slicedSelectorArr.length > 0) {\n    var gridTemplateFound = false;\n    var foundAreaSelector = null;\n    root.walkDecls(/grid-template(-areas)?$/, function (d) {\n      var parent = d.parent;\n      var templateSelectors = parent.selectors;\n\n      var _parseTemplate2 = parseTemplate({\n        decl: d,\n        gap: getGridGap(d)\n      }),\n          areas = _parseTemplate2.areas;\n\n      var hasArea = areas[decl.value]; // find the the matching selectors\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(templateSelectors), _step3; !(_step3 = _iterator3()).done;) {\n        var tplSelector = _step3.value;\n\n        if (gridTemplateFound) {\n          break;\n        }\n\n        var tplSelectorArr = list.space(tplSelector).filter(function (str) {\n          return str !== '>';\n        });\n        gridTemplateFound = tplSelectorArr.every(function (item, idx) {\n          return item === slicedSelectorArr[idx];\n        });\n      }\n\n      if (gridTemplateFound || !hasArea) {\n        return true;\n      }\n\n      if (!foundAreaSelector) {\n        foundAreaSelector = parent.selector;\n      } // if we found the duplicate area with different selector\n\n\n      if (foundAreaSelector && foundAreaSelector !== parent.selector) {\n        duplicatesFound = true;\n      }\n\n      return undefined;\n    }); // warn user if we didn't find template\n\n    if (!gridTemplateFound && duplicatesFound) {\n      decl.warn(result, 'Autoprefixer cannot find a grid-template ' + (\"containing the duplicate grid-area \\\"\" + decl.value + \"\\\" \") + (\"with full selector matching: \" + slicedSelectorArr.join(' ')));\n    }\n  }\n}\n/**\n * warn user if both grid-area and grid-(row|column)\n * declarations are present in the same rule\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnIfGridRowColumnExists(decl, result) {\n  var rule = decl.parent;\n  var decls = [];\n  rule.walkDecls(/^grid-(row|column)/, function (d) {\n    if (!d.prop.endsWith('-end') && !d.value.startsWith('span')) {\n      decls.push(d);\n    }\n  });\n\n  if (decls.length > 0) {\n    decls.forEach(function (d) {\n      d.warn(result, 'You already have a grid-area declaration present in the rule. ' + (\"You should use either grid-area or \" + d.prop + \", not both\"));\n    });\n  }\n\n  return undefined;\n} // Gap utils\n\n\nfunction getGridGap(decl) {\n  var gap = {}; // try to find gap\n\n  var testGap = /^(grid-)?((row|column)-)?gap$/;\n  decl.parent.walkDecls(testGap, function (_ref8) {\n    var prop = _ref8.prop,\n        value = _ref8.value;\n\n    if (/^(grid-)?gap$/.test(prop)) {\n      var _parser$nodes = parser(value).nodes,\n          row = _parser$nodes[0],\n          column = _parser$nodes[2];\n      gap.row = row && parser.stringify(row);\n      gap.column = column ? parser.stringify(column) : gap.row;\n    }\n\n    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value;\n    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value;\n  });\n  return gap;\n}\n/**\n * parse media parameters (for example 'min-width: 500px')\n * @param  {String} params parameter to parse\n * @return {}\n */\n\n\nfunction parseMediaParams(params) {\n  if (!params) {\n    return false;\n  }\n\n  var parsed = parser(params);\n  var prop;\n  var value;\n  parsed.walk(function (node) {\n    if (node.type === 'word' && /min|max/g.test(node.value)) {\n      prop = node.value;\n    } else if (node.value.includes('px')) {\n      value = parseInt(node.value.replace(/\\D/g, ''));\n    }\n  });\n  return [prop, value];\n}\n/**\n * Compare the selectors and decide if we\n * need to inherit gap from compared selector or not.\n * @type {String} selA\n * @type {String} selB\n * @return {Boolean}\n */\n\n\nfunction shouldInheritGap(selA, selB) {\n  var result; // get arrays of selector split in 3-deep array\n\n  var splitSelectorArrA = splitSelector(selA);\n  var splitSelectorArrB = splitSelector(selB);\n\n  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {\n    // abort if selectorA has lower descendant specificity then selectorB\n    // (e.g '.grid' and '.hello .world .grid')\n    return false;\n  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {\n    // if selectorA has higher descendant specificity then selectorB\n    // (e.g '.foo .bar .grid' and '.grid')\n    var idx = splitSelectorArrA[0].reduce(function (res, _ref9, index) {\n      var item = _ref9[0];\n      var firstSelectorPart = splitSelectorArrB[0][0][0];\n\n      if (item === firstSelectorPart) {\n        return index;\n      }\n\n      return false;\n    }, false);\n\n    if (idx) {\n      result = splitSelectorArrB[0].every(function (arr, index) {\n        return arr.every(function (part, innerIndex) {\n          return (// because selectorA has more space elements, we need to slice\n            // selectorA array by 'idx' number to compare them\n            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part\n          );\n        });\n      });\n    }\n  } else {\n    // if selectorA has the same descendant specificity as selectorB\n    // this condition covers cases such as: '.grid.foo.bar' and '.grid'\n    result = splitSelectorArrB.some(function (byCommaArr) {\n      return byCommaArr.every(function (bySpaceArr, index) {\n        return bySpaceArr.every(function (part, innerIndex) {\n          return splitSelectorArrA[0][index][innerIndex] === part;\n        });\n      });\n    });\n  }\n\n  return result;\n}\n/**\n * inherit grid gap values from the closest rule above\n * with the same selector\n * @param  {Declaration} decl\n * @param  {Object} gap gap values\n * @return {Object | Boolean} return gap values or false (if not found)\n */\n\n\nfunction inheritGridGap(decl, gap) {\n  var rule = decl.parent;\n  var mediaRule = getParentMedia(rule);\n  var root = rule.root(); // get an array of selector split in 3-deep array\n\n  var splitSelectorArr = splitSelector(rule.selector); // abort if the rule already has gaps\n\n  if (Object.keys(gap).length > 0) {\n    return false;\n  } // e.g ['min-width']\n\n\n  var _parseMediaParams = parseMediaParams(mediaRule.params),\n      prop = _parseMediaParams[0];\n\n  var lastBySpace = splitSelectorArr[0]; // get escaped value from the selector\n  // if we have '.grid-2.foo.bar' selector, will be '\\.grid\\-2'\n\n  var escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0]);\n  var regexp = new RegExp(\"(\" + escaped + \"$)|(\" + escaped + \"[,.])\"); // find the closest rule with the same selector\n\n  var closestRuleGap;\n  root.walkRules(regexp, function (r) {\n    var gridGap; // abort if are checking the same rule\n\n    if (rule.toString() === r.toString()) {\n      return false;\n    } // find grid-gap values\n\n\n    r.walkDecls('grid-gap', function (d) {\n      return gridGap = getGridGap(d);\n    }); // skip rule without gaps\n\n    if (!gridGap || Object.keys(gridGap).length === 0) {\n      return true;\n    } // skip rules that should not be inherited from\n\n\n    if (!shouldInheritGap(rule.selector, r.selector)) {\n      return true;\n    }\n\n    var media = getParentMedia(r);\n\n    if (media) {\n      // if we are inside media, we need to check that media props match\n      // e.g ('min-width' === 'min-width')\n      var propToCompare = parseMediaParams(media.params)[0];\n\n      if (propToCompare === prop) {\n        closestRuleGap = gridGap;\n        return true;\n      }\n    } else {\n      closestRuleGap = gridGap;\n      return true;\n    }\n\n    return undefined;\n  }); // if we find the closest gap object\n\n  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {\n    return closestRuleGap;\n  }\n\n  return false;\n}\n\nfunction warnGridGap(_ref10) {\n  var gap = _ref10.gap,\n      hasColumns = _ref10.hasColumns,\n      decl = _ref10.decl,\n      result = _ref10.result;\n  var hasBothGaps = gap.row && gap.column;\n\n  if (!hasColumns && (hasBothGaps || gap.column && !gap.row)) {\n    delete gap.column;\n    decl.warn(result, 'Can not implement grid-gap without grid-template-columns');\n  }\n}\n/**\n * normalize the grid-template-rows/columns values\n * @param  {String} str grid-template-rows/columns value\n * @return {Array} normalized array with values\n * @example\n * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')\n * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']\n */\n\n\nfunction normalizeRowColumn(str) {\n  var normalized = parser(str).nodes.reduce(function (result, node) {\n    if (node.type === 'function' && node.value === 'repeat') {\n      var key = 'count';\n\n      var _node$nodes$reduce = node.nodes.reduce(function (acc, n) {\n        if (n.type === 'word' && key === 'count') {\n          acc[0] = Math.abs(parseInt(n.value));\n          return acc;\n        }\n\n        if (n.type === 'div' && n.value === ',') {\n          key = 'value';\n          return acc;\n        }\n\n        if (key === 'value') {\n          acc[1] += parser.stringify(n);\n        }\n\n        return acc;\n      }, [0, '']),\n          count = _node$nodes$reduce[0],\n          value = _node$nodes$reduce[1];\n\n      if (count) {\n        for (var i = 0; i < count; i++) {\n          result.push(value);\n        }\n      }\n\n      return result;\n    }\n\n    if (node.type === 'space') {\n      return result;\n    }\n\n    return result.concat(parser.stringify(node));\n  }, []);\n  return normalized;\n}\n/**\n * Autoplace grid items\n * @param {Declaration} decl\n * @param {Result} result\n * @param {Object} gap gap values\n * @param {String} autoflowValue grid-auto-flow value\n * @return {void}\n * @see https://github.com/postcss/autoprefixer/issues/1148\n */\n\n\nfunction autoplaceGridItems(decl, result, gap, autoflowValue) {\n  if (autoflowValue === void 0) {\n    autoflowValue = 'row';\n  }\n\n  var parent = decl.parent;\n  var rowDecl = parent.nodes.find(function (i) {\n    return i.prop === 'grid-template-rows';\n  });\n  var rows = normalizeRowColumn(rowDecl.value);\n  var columns = normalizeRowColumn(decl.value); // Build array of area names with dummy values. If we have 3 columns and\n  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']\n\n  var filledRows = rows.map(function (_, rowIndex) {\n    return Array.from({\n      length: columns.length\n    }, function (v, k) {\n      return k + rowIndex * columns.length + 1;\n    }).join(' ');\n  });\n  var areas = parseGridAreas({\n    rows: filledRows,\n    gap: gap\n  });\n  var keys = Object.keys(areas);\n  var items = keys.map(function (i) {\n    return areas[i];\n  }); // Change the order of cells if grid-auto-flow value is 'column'\n\n  if (autoflowValue.includes('column')) {\n    items = items.sort(function (a, b) {\n      return a.column.start - b.column.start;\n    });\n  } // Insert new rules\n\n\n  items.reverse().forEach(function (item, index) {\n    var column = item.column,\n        row = item.row;\n    var nodeSelector = parent.selectors.map(function (sel) {\n      return sel + (\" > *:nth-child(\" + (keys.length - index) + \")\");\n    }).join(', '); // create new rule\n\n    var node = parent.clone().removeAll(); // change rule selector\n\n    node.selector = nodeSelector; // insert prefixed row/column values\n\n    node.append({\n      prop: '-ms-grid-row',\n      value: row.start\n    });\n    node.append({\n      prop: '-ms-grid-column',\n      value: column.start\n    }); // insert rule\n\n    parent.after(node);\n  });\n  return undefined;\n}\n\nmodule.exports = {\n  parse: parse,\n  translate: translate,\n  parseTemplate: parseTemplate,\n  parseGridAreas: parseGridAreas,\n  warnMissedAreas: warnMissedAreas,\n  insertAreas: insertAreas,\n  insertDecl: insertDecl,\n  prefixTrackProp: prefixTrackProp,\n  prefixTrackValue: prefixTrackValue,\n  getGridGap: getGridGap,\n  warnGridGap: warnGridGap,\n  warnTemplateSelectorNotFound: warnTemplateSelectorNotFound,\n  warnIfGridRowColumnExists: warnIfGridRowColumnExists,\n  inheritGridGap: inheritGridGap,\n  autoplaceGridItems: autoplaceGridItems\n};","map":{"version":3,"sources":["/bioacustica/node_modules/autoprefixer/lib/hacks/grid-utils.js"],"names":["_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","done","value","TypeError","next","bind","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","parser","require","list","uniq","escapeRegexp","splitSelector","convert","parseInt","translate","values","startIndex","endIndex","startValue","endValue","_convert","start","spanStart","_convert2","end","spanEnd","parse","decl","node","current","_iterator","nodes","_step","type","push","insertDecl","prop","parent","some","cloneBefore","prefixTrackProp","_ref","prefix","replace","transformRepeat","_ref2","_ref3","gap","_nodes$reduce","reduce","result","key","stringify","size","count","_ret","filter","trim","val","_loop","forEach","item","index","v","join","prefixTrackValue","_ref4","concat","DOTS","track","span","getColumns","line","split","parseGridAreas","_ref5","rows","areas","rowIndex","row","area","columnIndex","column","_areas$area","Math","min","max","testTrack","verifyRowSize","parseTemplate","_ref6","gridTemplate","columns","getMSDecls","addRowSpan","addColumnSpan","String","getParentMedia","changeDuplicateAreaSelectors","ruleSelectors","templateSelectors","map","selector","selectorBySpace","space","selectorByComma","comma","ruleSelector","newSelector","tplSelector","selectorsEqual","ruleA","ruleB","selectors","sel","s","parseGridTemplatesData","css","parsed","walkDecls","d","rule","media","getGridGap","inheritedGap","inheritGridGap","_parseTemplate","areaNames","keys","acc","_ref7","idx","allAreas","hasAreas","includes","_parsed$index","rules","hasNoDuplicates","r","hasDuplicates","duplicatesFound","duplicateAreaNames","params","updateSpan","areasCount","duplicateRules","undefined","insertAreas","isDisabled","gridTemplatesData","rulesToInsert","gridArea","gridAreaRule","hasPrefixedRow","first","gridAreaMedia","gridAreaRuleIndex","data","lastArea","selectorIsComplex","lastRuleIsSet","_iterator2","_step2","hasDuplicateName","lastRuleIndex","lastRule","reverse","prepend","assign","raws","between","cloned","clone","removeAll","after","remove","append","p","warnMissedAreas","missed","root","e","warn","warnTemplateSelectorNotFound","slicedSelectorArr","str","gridTemplateFound","foundAreaSelector","_parseTemplate2","hasArea","_iterator3","_step3","tplSelectorArr","every","warnIfGridRowColumnExists","decls","endsWith","startsWith","testGap","_ref8","_parser$nodes","parseMediaParams","walk","shouldInheritGap","selA","selB","splitSelectorArrA","splitSelectorArrB","res","_ref9","firstSelectorPart","part","innerIndex","byCommaArr","bySpaceArr","mediaRule","splitSelectorArr","_parseMediaParams","lastBySpace","escaped","regexp","RegExp","closestRuleGap","walkRules","gridGap","propToCompare","warnGridGap","_ref10","hasColumns","hasBothGaps","normalizeRowColumn","normalized","_node$nodes$reduce","abs","autoplaceGridItems","autoflowValue","rowDecl","find","filledRows","_","k","items","sort","a","b","nodeSelector","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar parser = require('postcss-value-parser');\n\nvar list = require('postcss').list;\n\nvar uniq = require('../utils').uniq;\n\nvar escapeRegexp = require('../utils').escapeRegexp;\n\nvar splitSelector = require('../utils').splitSelector;\n\nfunction convert(value) {\n  if (value && value.length === 2 && value[0] === 'span' && parseInt(value[1], 10) > 0) {\n    return [false, parseInt(value[1], 10)];\n  }\n\n  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {\n    return [parseInt(value[0], 10), false];\n  }\n\n  return [false, false];\n}\n\nfunction translate(values, startIndex, endIndex) {\n  var startValue = values[startIndex];\n  var endValue = values[endIndex];\n\n  if (!startValue) {\n    return [false, false];\n  }\n\n  var _convert = convert(startValue),\n      start = _convert[0],\n      spanStart = _convert[1];\n\n  var _convert2 = convert(endValue),\n      end = _convert2[0],\n      spanEnd = _convert2[1];\n\n  if (start && !endValue) {\n    return [start, false];\n  }\n\n  if (spanStart && end) {\n    return [end - spanStart, spanStart];\n  }\n\n  if (start && spanEnd) {\n    return [start, spanEnd];\n  }\n\n  if (start && end) {\n    return [start, end - start];\n  }\n\n  return [false, false];\n}\n\nfunction parse(decl) {\n  var node = parser(decl.value);\n  var values = [];\n  var current = 0;\n  values[current] = [];\n\n  for (var _iterator = _createForOfIteratorHelperLoose(node.nodes), _step; !(_step = _iterator()).done;) {\n    var i = _step.value;\n\n    if (i.type === 'div') {\n      current += 1;\n      values[current] = [];\n    } else if (i.type === 'word') {\n      values[current].push(i.value);\n    }\n  }\n\n  return values;\n}\n\nfunction insertDecl(decl, prop, value) {\n  if (value && !decl.parent.some(function (i) {\n    return i.prop === \"-ms-\" + prop;\n  })) {\n    decl.cloneBefore({\n      prop: \"-ms-\" + prop,\n      value: value.toString()\n    });\n  }\n} // Track transforms\n\n\nfunction prefixTrackProp(_ref) {\n  var prop = _ref.prop,\n      prefix = _ref.prefix;\n  return prefix + prop.replace('template-', '');\n}\n\nfunction transformRepeat(_ref2, _ref3) {\n  var nodes = _ref2.nodes;\n  var gap = _ref3.gap;\n\n  var _nodes$reduce = nodes.reduce(function (result, node) {\n    if (node.type === 'div' && node.value === ',') {\n      result.key = 'size';\n    } else {\n      result[result.key].push(parser.stringify(node));\n    }\n\n    return result;\n  }, {\n    key: 'count',\n    size: [],\n    count: []\n  }),\n      count = _nodes$reduce.count,\n      size = _nodes$reduce.size; // insert gap values\n\n\n  if (gap) {\n    var _ret = function () {\n      size = size.filter(function (i) {\n        return i.trim();\n      });\n      var val = [];\n\n      var _loop = function _loop(i) {\n        size.forEach(function (item, index) {\n          if (index > 0 || i > 1) {\n            val.push(gap);\n          }\n\n          val.push(item);\n        });\n      };\n\n      for (var i = 1; i <= count; i++) {\n        _loop(i);\n      }\n\n      return {\n        v: val.join(' ')\n      };\n    }();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  return \"(\" + size.join('') + \")[\" + count.join('') + \"]\";\n}\n\nfunction prefixTrackValue(_ref4) {\n  var value = _ref4.value,\n      gap = _ref4.gap;\n  var result = parser(value).nodes.reduce(function (nodes, node) {\n    if (node.type === 'function' && node.value === 'repeat') {\n      return nodes.concat({\n        type: 'word',\n        value: transformRepeat(node, {\n          gap: gap\n        })\n      });\n    }\n\n    if (gap && node.type === 'space') {\n      return nodes.concat({\n        type: 'space',\n        value: ' '\n      }, {\n        type: 'word',\n        value: gap\n      }, node);\n    }\n\n    return nodes.concat(node);\n  }, []);\n  return parser.stringify(result);\n} // Parse grid-template-areas\n\n\nvar DOTS = /^\\.+$/;\n\nfunction track(start, end) {\n  return {\n    start: start,\n    end: end,\n    span: end - start\n  };\n}\n\nfunction getColumns(line) {\n  return line.trim().split(/\\s+/g);\n}\n\nfunction parseGridAreas(_ref5) {\n  var rows = _ref5.rows,\n      gap = _ref5.gap;\n  return rows.reduce(function (areas, line, rowIndex) {\n    if (gap.row) rowIndex *= 2;\n    if (line.trim() === '') return areas;\n    getColumns(line).forEach(function (area, columnIndex) {\n      if (DOTS.test(area)) return;\n      if (gap.column) columnIndex *= 2;\n\n      if (typeof areas[area] === 'undefined') {\n        areas[area] = {\n          column: track(columnIndex + 1, columnIndex + 2),\n          row: track(rowIndex + 1, rowIndex + 2)\n        };\n      } else {\n        var _areas$area = areas[area],\n            column = _areas$area.column,\n            row = _areas$area.row;\n        column.start = Math.min(column.start, columnIndex + 1);\n        column.end = Math.max(column.end, columnIndex + 2);\n        column.span = column.end - column.start;\n        row.start = Math.min(row.start, rowIndex + 1);\n        row.end = Math.max(row.end, rowIndex + 2);\n        row.span = row.end - row.start;\n      }\n    });\n    return areas;\n  }, {});\n} // Parse grid-template\n\n\nfunction testTrack(node) {\n  return node.type === 'word' && /^\\[.+]$/.test(node.value);\n}\n\nfunction verifyRowSize(result) {\n  if (result.areas.length > result.rows.length) {\n    result.rows.push('auto');\n  }\n\n  return result;\n}\n\nfunction parseTemplate(_ref6) {\n  var decl = _ref6.decl,\n      gap = _ref6.gap;\n  var gridTemplate = parser(decl.value).nodes.reduce(function (result, node) {\n    var type = node.type,\n        value = node.value;\n    if (testTrack(node) || type === 'space') return result; // area\n\n    if (type === 'string') {\n      result = verifyRowSize(result);\n      result.areas.push(value);\n    } // values and function\n\n\n    if (type === 'word' || type === 'function') {\n      result[result.key].push(parser.stringify(node));\n    } // divider(/)\n\n\n    if (type === 'div' && value === '/') {\n      result.key = 'columns';\n      result = verifyRowSize(result);\n    }\n\n    return result;\n  }, {\n    key: 'rows',\n    columns: [],\n    rows: [],\n    areas: []\n  });\n  return {\n    areas: parseGridAreas({\n      rows: gridTemplate.areas,\n      gap: gap\n    }),\n    columns: prefixTrackValue({\n      value: gridTemplate.columns.join(' '),\n      gap: gap.column\n    }),\n    rows: prefixTrackValue({\n      value: gridTemplate.rows.join(' '),\n      gap: gap.row\n    })\n  };\n} // Insert parsed grid areas\n\n/**\n * Get an array of -ms- prefixed props and values\n * @param  {Object} [area] area object with column and row data\n * @param  {Boolean} [addRowSpan] should we add grid-column-row value?\n * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?\n * @return {Array<Object>}\n */\n\n\nfunction getMSDecls(area, addRowSpan, addColumnSpan) {\n  if (addRowSpan === void 0) {\n    addRowSpan = false;\n  }\n\n  if (addColumnSpan === void 0) {\n    addColumnSpan = false;\n  }\n\n  return [].concat({\n    prop: '-ms-grid-row',\n    value: String(area.row.start)\n  }, area.row.span > 1 || addRowSpan ? {\n    prop: '-ms-grid-row-span',\n    value: String(area.row.span)\n  } : [], {\n    prop: '-ms-grid-column',\n    value: String(area.column.start)\n  }, area.column.span > 1 || addColumnSpan ? {\n    prop: '-ms-grid-column-span',\n    value: String(area.column.span)\n  } : []);\n}\n\nfunction getParentMedia(parent) {\n  if (parent.type === 'atrule' && parent.name === 'media') {\n    return parent;\n  }\n\n  if (!parent.parent) {\n    return false;\n  }\n\n  return getParentMedia(parent.parent);\n}\n/**\n * change selectors for rules with duplicate grid-areas.\n * @param  {Array<Rule>} rules\n * @param  {Array<String>} templateSelectors\n * @return {Array<Rule>} rules with changed selectors\n */\n\n\nfunction changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {\n  ruleSelectors = ruleSelectors.map(function (selector) {\n    var selectorBySpace = list.space(selector);\n    var selectorByComma = list.comma(selector);\n\n    if (selectorBySpace.length > selectorByComma.length) {\n      selector = selectorBySpace.slice(-1).join('');\n    }\n\n    return selector;\n  });\n  return ruleSelectors.map(function (ruleSelector) {\n    var newSelector = templateSelectors.map(function (tplSelector, index) {\n      var space = index === 0 ? '' : ' ';\n      return \"\" + space + tplSelector + \" > \" + ruleSelector;\n    });\n    return newSelector;\n  });\n}\n/**\n * check if selector of rules are equal\n * @param  {Rule} ruleA\n * @param  {Rule} ruleB\n * @return {Boolean}\n */\n\n\nfunction selectorsEqual(ruleA, ruleB) {\n  return ruleA.selectors.some(function (sel) {\n    return ruleB.selectors.some(function (s) {\n      return s === sel;\n    });\n  });\n}\n/**\n * Parse data from all grid-template(-areas) declarations\n * @param  {Root} css css root\n * @return {Object} parsed data\n */\n\n\nfunction parseGridTemplatesData(css) {\n  var parsed = []; // we walk through every grid-template(-areas) declaration and store\n  // data with the same area names inside the item\n\n  css.walkDecls(/grid-template(-areas)?$/, function (d) {\n    var rule = d.parent;\n    var media = getParentMedia(rule);\n    var gap = getGridGap(d);\n    var inheritedGap = inheritGridGap(d, gap);\n\n    var _parseTemplate = parseTemplate({\n      decl: d,\n      gap: inheritedGap || gap\n    }),\n        areas = _parseTemplate.areas;\n\n    var areaNames = Object.keys(areas); // skip node if it doesn't have areas\n\n    if (areaNames.length === 0) {\n      return true;\n    } // check parsed array for item that include the same area names\n    // return index of that item\n\n\n    var index = parsed.reduce(function (acc, _ref7, idx) {\n      var allAreas = _ref7.allAreas;\n      var hasAreas = allAreas && areaNames.some(function (area) {\n        return allAreas.includes(area);\n      });\n      return hasAreas ? idx : acc;\n    }, null);\n\n    if (index !== null) {\n      // index is found, add the grid-template data to that item\n      var _parsed$index = parsed[index],\n          allAreas = _parsed$index.allAreas,\n          rules = _parsed$index.rules; // check if rule has no duplicate area names\n\n      var hasNoDuplicates = rules.some(function (r) {\n        return r.hasDuplicates === false && selectorsEqual(r, rule);\n      });\n      var duplicatesFound = false; // check need to gather all duplicate area names\n\n      var duplicateAreaNames = rules.reduce(function (acc, r) {\n        if (!r.params && selectorsEqual(r, rule)) {\n          duplicatesFound = true;\n          return r.duplicateAreaNames;\n        }\n\n        if (!duplicatesFound) {\n          areaNames.forEach(function (name) {\n            if (r.areas[name]) {\n              acc.push(name);\n            }\n          });\n        }\n\n        return uniq(acc);\n      }, []); // update grid-row/column-span values for areas with duplicate\n      // area names. @see #1084 and #1146\n\n      rules.forEach(function (r) {\n        areaNames.forEach(function (name) {\n          var area = r.areas[name];\n\n          if (area && area.row.span !== areas[name].row.span) {\n            areas[name].row.updateSpan = true;\n          }\n\n          if (area && area.column.span !== areas[name].column.span) {\n            areas[name].column.updateSpan = true;\n          }\n        });\n      });\n      parsed[index].allAreas = uniq([].concat(allAreas, areaNames));\n      parsed[index].rules.push({\n        hasDuplicates: !hasNoDuplicates,\n        params: media.params,\n        selectors: rule.selectors,\n        node: rule,\n        duplicateAreaNames: duplicateAreaNames,\n        areas: areas\n      });\n    } else {\n      // index is NOT found, push the new item to the parsed array\n      parsed.push({\n        allAreas: areaNames,\n        areasCount: 0,\n        rules: [{\n          hasDuplicates: false,\n          duplicateRules: [],\n          params: media.params,\n          selectors: rule.selectors,\n          node: rule,\n          duplicateAreaNames: [],\n          areas: areas\n        }]\n      });\n    }\n\n    return undefined;\n  });\n  return parsed;\n}\n/**\n * insert prefixed grid-area declarations\n * @param  {Root}  css css root\n * @param  {Function} isDisabled check if the rule is disabled\n * @return {void}\n */\n\n\nfunction insertAreas(css, isDisabled) {\n  // parse grid-template declarations\n  var gridTemplatesData = parseGridTemplatesData(css); // return undefined if no declarations found\n\n  if (gridTemplatesData.length === 0) {\n    return undefined;\n  } // we need to store the rules that we will insert later\n\n\n  var rulesToInsert = {};\n  css.walkDecls('grid-area', function (gridArea) {\n    var gridAreaRule = gridArea.parent;\n    var hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row';\n    var gridAreaMedia = getParentMedia(gridAreaRule);\n\n    if (isDisabled(gridArea)) {\n      return undefined;\n    }\n\n    var gridAreaRuleIndex = gridAreaMedia ? css.index(gridAreaMedia) : css.index(gridAreaRule);\n    var value = gridArea.value; // found the data that matches grid-area identifier\n\n    var data = gridTemplatesData.filter(function (d) {\n      return d.allAreas.includes(value);\n    })[0];\n\n    if (!data) {\n      return true;\n    }\n\n    var lastArea = data.allAreas[data.allAreas.length - 1];\n    var selectorBySpace = list.space(gridAreaRule.selector);\n    var selectorByComma = list.comma(gridAreaRule.selector);\n    var selectorIsComplex = selectorBySpace.length > 1 && selectorBySpace.length > selectorByComma.length; // prevent doubling of prefixes\n\n    if (hasPrefixedRow) {\n      return false;\n    } // create the empty object with the key as the last area name\n    // e.g if we have templates with \"a b c\" values, \"c\" will be the last area\n\n\n    if (!rulesToInsert[lastArea]) {\n      rulesToInsert[lastArea] = {};\n    }\n\n    var lastRuleIsSet = false; // walk through every grid-template rule data\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(data.rules), _step2; !(_step2 = _iterator2()).done;) {\n      var rule = _step2.value;\n      var area = rule.areas[value];\n      var hasDuplicateName = rule.duplicateAreaNames.includes(value); // if we can't find the area name, update lastRule and continue\n\n      if (!area) {\n        var lastRuleIndex = css.index(rulesToInsert[lastArea].lastRule);\n\n        if (gridAreaRuleIndex > lastRuleIndex) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n        }\n\n        continue;\n      } // for grid-templates inside media rule we need to create empty\n      // array to push prefixed grid-area rules later\n\n\n      if (rule.params && !rulesToInsert[lastArea][rule.params]) {\n        rulesToInsert[lastArea][rule.params] = [];\n      }\n\n      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {\n        // grid-template has no duplicates and not inside media rule\n        getMSDecls(area, false, false).reverse().forEach(function (i) {\n          return gridAreaRule.prepend(Object.assign(i, {\n            raws: {\n              between: gridArea.raws.between\n            }\n          }));\n        });\n        rulesToInsert[lastArea].lastRule = gridAreaRule;\n        lastRuleIsSet = true;\n      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {\n        (function () {\n          // grid-template has duplicates and not inside media rule\n          var cloned = gridAreaRule.clone();\n          cloned.removeAll();\n          getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n            return cloned.prepend(Object.assign(i, {\n              raws: {\n                between: gridArea.raws.between\n              }\n            }));\n          });\n          cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n\n          if (rulesToInsert[lastArea].lastRule) {\n            rulesToInsert[lastArea].lastRule.after(cloned);\n          }\n\n          rulesToInsert[lastArea].lastRule = cloned;\n          lastRuleIsSet = true;\n        })();\n      } else if (rule.hasDuplicates && !rule.params && selectorIsComplex && gridAreaRule.selector.includes(rule.selectors[0])) {\n        // grid-template has duplicates and not inside media rule\n        // and the selector is complex\n        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, function (d) {\n          return d.remove();\n        });\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n          return gridAreaRule.prepend(Object.assign(i, {\n            raws: {\n              between: gridArea.raws.between\n            }\n          }));\n        });\n      } else if (rule.params) {\n        (function () {\n          // grid-template is inside media rule\n          // if we're inside media rule, we need to store prefixed rules\n          // inside rulesToInsert object to be able to preserve the order of media\n          // rules and merge them easily\n          var cloned = gridAreaRule.clone();\n          cloned.removeAll();\n          getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n            return cloned.prepend(Object.assign(i, {\n              raws: {\n                between: gridArea.raws.between\n              }\n            }));\n          });\n\n          if (rule.hasDuplicates && hasDuplicateName) {\n            cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n          }\n\n          cloned.raws = rule.node.raws;\n\n          if (css.index(rule.node.parent) > gridAreaRuleIndex) {\n            // append the prefixed rules right inside media rule\n            // with grid-template\n            rule.node.parent.append(cloned);\n          } else {\n            // store the rule to insert later\n            rulesToInsert[lastArea][rule.params].push(cloned);\n          } // set new rule as last rule ONLY if we didn't set lastRule for\n          // this grid-area before\n\n\n          if (!lastRuleIsSet) {\n            rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n          }\n        })();\n      }\n    }\n\n    return undefined;\n  }); // append stored rules inside the media rules\n\n  Object.keys(rulesToInsert).forEach(function (area) {\n    var data = rulesToInsert[area];\n    var lastRule = data.lastRule;\n    Object.keys(data).reverse().filter(function (p) {\n      return p !== 'lastRule';\n    }).forEach(function (params) {\n      if (data[params].length > 0 && lastRule) {\n        lastRule.after({\n          name: 'media',\n          params: params\n        });\n        lastRule.next().append(data[params]);\n      }\n    });\n  });\n  return undefined;\n}\n/**\n * Warn user if grid area identifiers are not found\n * @param  {Object} areas\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnMissedAreas(areas, decl, result) {\n  var missed = Object.keys(areas);\n  decl.root().walkDecls('grid-area', function (gridArea) {\n    missed = missed.filter(function (e) {\n      return e !== gridArea.value;\n    });\n  });\n\n  if (missed.length > 0) {\n    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '));\n  }\n\n  return undefined;\n}\n/**\n * compare selectors with grid-area rule and grid-template rule\n * show warning if grid-template selector is not found\n * (this function used for grid-area rule)\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnTemplateSelectorNotFound(decl, result) {\n  var rule = decl.parent;\n  var root = decl.root();\n  var duplicatesFound = false; // slice selector array. Remove the last part (for comparison)\n\n  var slicedSelectorArr = list.space(rule.selector).filter(function (str) {\n    return str !== '>';\n  }).slice(0, -1); // we need to compare only if selector is complex.\n  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex\n\n  if (slicedSelectorArr.length > 0) {\n    var gridTemplateFound = false;\n    var foundAreaSelector = null;\n    root.walkDecls(/grid-template(-areas)?$/, function (d) {\n      var parent = d.parent;\n      var templateSelectors = parent.selectors;\n\n      var _parseTemplate2 = parseTemplate({\n        decl: d,\n        gap: getGridGap(d)\n      }),\n          areas = _parseTemplate2.areas;\n\n      var hasArea = areas[decl.value]; // find the the matching selectors\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(templateSelectors), _step3; !(_step3 = _iterator3()).done;) {\n        var tplSelector = _step3.value;\n\n        if (gridTemplateFound) {\n          break;\n        }\n\n        var tplSelectorArr = list.space(tplSelector).filter(function (str) {\n          return str !== '>';\n        });\n        gridTemplateFound = tplSelectorArr.every(function (item, idx) {\n          return item === slicedSelectorArr[idx];\n        });\n      }\n\n      if (gridTemplateFound || !hasArea) {\n        return true;\n      }\n\n      if (!foundAreaSelector) {\n        foundAreaSelector = parent.selector;\n      } // if we found the duplicate area with different selector\n\n\n      if (foundAreaSelector && foundAreaSelector !== parent.selector) {\n        duplicatesFound = true;\n      }\n\n      return undefined;\n    }); // warn user if we didn't find template\n\n    if (!gridTemplateFound && duplicatesFound) {\n      decl.warn(result, 'Autoprefixer cannot find a grid-template ' + (\"containing the duplicate grid-area \\\"\" + decl.value + \"\\\" \") + (\"with full selector matching: \" + slicedSelectorArr.join(' ')));\n    }\n  }\n}\n/**\n * warn user if both grid-area and grid-(row|column)\n * declarations are present in the same rule\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnIfGridRowColumnExists(decl, result) {\n  var rule = decl.parent;\n  var decls = [];\n  rule.walkDecls(/^grid-(row|column)/, function (d) {\n    if (!d.prop.endsWith('-end') && !d.value.startsWith('span')) {\n      decls.push(d);\n    }\n  });\n\n  if (decls.length > 0) {\n    decls.forEach(function (d) {\n      d.warn(result, 'You already have a grid-area declaration present in the rule. ' + (\"You should use either grid-area or \" + d.prop + \", not both\"));\n    });\n  }\n\n  return undefined;\n} // Gap utils\n\n\nfunction getGridGap(decl) {\n  var gap = {}; // try to find gap\n\n  var testGap = /^(grid-)?((row|column)-)?gap$/;\n  decl.parent.walkDecls(testGap, function (_ref8) {\n    var prop = _ref8.prop,\n        value = _ref8.value;\n\n    if (/^(grid-)?gap$/.test(prop)) {\n      var _parser$nodes = parser(value).nodes,\n          row = _parser$nodes[0],\n          column = _parser$nodes[2];\n      gap.row = row && parser.stringify(row);\n      gap.column = column ? parser.stringify(column) : gap.row;\n    }\n\n    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value;\n    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value;\n  });\n  return gap;\n}\n/**\n * parse media parameters (for example 'min-width: 500px')\n * @param  {String} params parameter to parse\n * @return {}\n */\n\n\nfunction parseMediaParams(params) {\n  if (!params) {\n    return false;\n  }\n\n  var parsed = parser(params);\n  var prop;\n  var value;\n  parsed.walk(function (node) {\n    if (node.type === 'word' && /min|max/g.test(node.value)) {\n      prop = node.value;\n    } else if (node.value.includes('px')) {\n      value = parseInt(node.value.replace(/\\D/g, ''));\n    }\n  });\n  return [prop, value];\n}\n/**\n * Compare the selectors and decide if we\n * need to inherit gap from compared selector or not.\n * @type {String} selA\n * @type {String} selB\n * @return {Boolean}\n */\n\n\nfunction shouldInheritGap(selA, selB) {\n  var result; // get arrays of selector split in 3-deep array\n\n  var splitSelectorArrA = splitSelector(selA);\n  var splitSelectorArrB = splitSelector(selB);\n\n  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {\n    // abort if selectorA has lower descendant specificity then selectorB\n    // (e.g '.grid' and '.hello .world .grid')\n    return false;\n  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {\n    // if selectorA has higher descendant specificity then selectorB\n    // (e.g '.foo .bar .grid' and '.grid')\n    var idx = splitSelectorArrA[0].reduce(function (res, _ref9, index) {\n      var item = _ref9[0];\n      var firstSelectorPart = splitSelectorArrB[0][0][0];\n\n      if (item === firstSelectorPart) {\n        return index;\n      }\n\n      return false;\n    }, false);\n\n    if (idx) {\n      result = splitSelectorArrB[0].every(function (arr, index) {\n        return arr.every(function (part, innerIndex) {\n          return (// because selectorA has more space elements, we need to slice\n            // selectorA array by 'idx' number to compare them\n            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part\n          );\n        });\n      });\n    }\n  } else {\n    // if selectorA has the same descendant specificity as selectorB\n    // this condition covers cases such as: '.grid.foo.bar' and '.grid'\n    result = splitSelectorArrB.some(function (byCommaArr) {\n      return byCommaArr.every(function (bySpaceArr, index) {\n        return bySpaceArr.every(function (part, innerIndex) {\n          return splitSelectorArrA[0][index][innerIndex] === part;\n        });\n      });\n    });\n  }\n\n  return result;\n}\n/**\n * inherit grid gap values from the closest rule above\n * with the same selector\n * @param  {Declaration} decl\n * @param  {Object} gap gap values\n * @return {Object | Boolean} return gap values or false (if not found)\n */\n\n\nfunction inheritGridGap(decl, gap) {\n  var rule = decl.parent;\n  var mediaRule = getParentMedia(rule);\n  var root = rule.root(); // get an array of selector split in 3-deep array\n\n  var splitSelectorArr = splitSelector(rule.selector); // abort if the rule already has gaps\n\n  if (Object.keys(gap).length > 0) {\n    return false;\n  } // e.g ['min-width']\n\n\n  var _parseMediaParams = parseMediaParams(mediaRule.params),\n      prop = _parseMediaParams[0];\n\n  var lastBySpace = splitSelectorArr[0]; // get escaped value from the selector\n  // if we have '.grid-2.foo.bar' selector, will be '\\.grid\\-2'\n\n  var escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0]);\n  var regexp = new RegExp(\"(\" + escaped + \"$)|(\" + escaped + \"[,.])\"); // find the closest rule with the same selector\n\n  var closestRuleGap;\n  root.walkRules(regexp, function (r) {\n    var gridGap; // abort if are checking the same rule\n\n    if (rule.toString() === r.toString()) {\n      return false;\n    } // find grid-gap values\n\n\n    r.walkDecls('grid-gap', function (d) {\n      return gridGap = getGridGap(d);\n    }); // skip rule without gaps\n\n    if (!gridGap || Object.keys(gridGap).length === 0) {\n      return true;\n    } // skip rules that should not be inherited from\n\n\n    if (!shouldInheritGap(rule.selector, r.selector)) {\n      return true;\n    }\n\n    var media = getParentMedia(r);\n\n    if (media) {\n      // if we are inside media, we need to check that media props match\n      // e.g ('min-width' === 'min-width')\n      var propToCompare = parseMediaParams(media.params)[0];\n\n      if (propToCompare === prop) {\n        closestRuleGap = gridGap;\n        return true;\n      }\n    } else {\n      closestRuleGap = gridGap;\n      return true;\n    }\n\n    return undefined;\n  }); // if we find the closest gap object\n\n  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {\n    return closestRuleGap;\n  }\n\n  return false;\n}\n\nfunction warnGridGap(_ref10) {\n  var gap = _ref10.gap,\n      hasColumns = _ref10.hasColumns,\n      decl = _ref10.decl,\n      result = _ref10.result;\n  var hasBothGaps = gap.row && gap.column;\n\n  if (!hasColumns && (hasBothGaps || gap.column && !gap.row)) {\n    delete gap.column;\n    decl.warn(result, 'Can not implement grid-gap without grid-template-columns');\n  }\n}\n/**\n * normalize the grid-template-rows/columns values\n * @param  {String} str grid-template-rows/columns value\n * @return {Array} normalized array with values\n * @example\n * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')\n * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']\n */\n\n\nfunction normalizeRowColumn(str) {\n  var normalized = parser(str).nodes.reduce(function (result, node) {\n    if (node.type === 'function' && node.value === 'repeat') {\n      var key = 'count';\n\n      var _node$nodes$reduce = node.nodes.reduce(function (acc, n) {\n        if (n.type === 'word' && key === 'count') {\n          acc[0] = Math.abs(parseInt(n.value));\n          return acc;\n        }\n\n        if (n.type === 'div' && n.value === ',') {\n          key = 'value';\n          return acc;\n        }\n\n        if (key === 'value') {\n          acc[1] += parser.stringify(n);\n        }\n\n        return acc;\n      }, [0, '']),\n          count = _node$nodes$reduce[0],\n          value = _node$nodes$reduce[1];\n\n      if (count) {\n        for (var i = 0; i < count; i++) {\n          result.push(value);\n        }\n      }\n\n      return result;\n    }\n\n    if (node.type === 'space') {\n      return result;\n    }\n\n    return result.concat(parser.stringify(node));\n  }, []);\n  return normalized;\n}\n/**\n * Autoplace grid items\n * @param {Declaration} decl\n * @param {Result} result\n * @param {Object} gap gap values\n * @param {String} autoflowValue grid-auto-flow value\n * @return {void}\n * @see https://github.com/postcss/autoprefixer/issues/1148\n */\n\n\nfunction autoplaceGridItems(decl, result, gap, autoflowValue) {\n  if (autoflowValue === void 0) {\n    autoflowValue = 'row';\n  }\n\n  var parent = decl.parent;\n  var rowDecl = parent.nodes.find(function (i) {\n    return i.prop === 'grid-template-rows';\n  });\n  var rows = normalizeRowColumn(rowDecl.value);\n  var columns = normalizeRowColumn(decl.value); // Build array of area names with dummy values. If we have 3 columns and\n  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']\n\n  var filledRows = rows.map(function (_, rowIndex) {\n    return Array.from({\n      length: columns.length\n    }, function (v, k) {\n      return k + rowIndex * columns.length + 1;\n    }).join(' ');\n  });\n  var areas = parseGridAreas({\n    rows: filledRows,\n    gap: gap\n  });\n  var keys = Object.keys(areas);\n  var items = keys.map(function (i) {\n    return areas[i];\n  }); // Change the order of cells if grid-auto-flow value is 'column'\n\n  if (autoflowValue.includes('column')) {\n    items = items.sort(function (a, b) {\n      return a.column.start - b.column.start;\n    });\n  } // Insert new rules\n\n\n  items.reverse().forEach(function (item, index) {\n    var column = item.column,\n        row = item.row;\n    var nodeSelector = parent.selectors.map(function (sel) {\n      return sel + (\" > *:nth-child(\" + (keys.length - index) + \")\");\n    }).join(', '); // create new rule\n\n    var node = parent.clone().removeAll(); // change rule selector\n\n    node.selector = nodeSelector; // insert prefixed row/column values\n\n    node.append({\n      prop: '-ms-grid-row',\n      value: row.start\n    });\n    node.append({\n      prop: '-ms-grid-column',\n      value: column.start\n    }); // insert rule\n\n    parent.after(node);\n  });\n  return undefined;\n}\n\nmodule.exports = {\n  parse: parse,\n  translate: translate,\n  parseTemplate: parseTemplate,\n  parseGridAreas: parseGridAreas,\n  warnMissedAreas: warnMissedAreas,\n  insertAreas: insertAreas,\n  insertDecl: insertDecl,\n  prefixTrackProp: prefixTrackProp,\n  prefixTrackValue: prefixTrackValue,\n  getGridGap: getGridGap,\n  warnGridGap: warnGridGap,\n  warnTemplateSelectorNotFound: warnTemplateSelectorNotFound,\n  warnIfGridRowColumnExists: warnIfGridRowColumnExists,\n  inheritGridGap: inheritGridGap,\n  autoplaceGridItems: autoplaceGridItems\n};"]},"metadata":{},"sourceType":"script"}